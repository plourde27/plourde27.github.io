<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Maps</title>
        <link href='//fonts.googleapis.com/css?family=Montserrat:thin,extra-light,light,100,200,300,400,500,600,700,800'
rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
  integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
  crossorigin=""/>
        <link rel="stylesheet" type="text/css" href="../styles.css">
        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
crossorigin=""></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
        <style>

        </style>
    </head>
    <body>
      <div id="title">
      <br><br><h1>Safe Biking Directions Calculator</h1>
      <p>Made by Xavier Plourde for EDD class</p>
      <p>This project calculates safe biking directions between two points, based on a variety of road parameters including traffic level, shoulder size, and speed limit. The program finds the shortest route between the two points that fits user-controlled safety parameters.</p>
      <p>You can also "blacklist" roads, making the program never include the road in a route, or "whitelist" roads, making the program always consider the road in a route.<br><br>
      <p>Disclaimer: the safety of roads calculated in this program is based on a computerized algorithm, and may not always be perfectly accurate. Always use your best judgment when biking on roads, regardless of how safe this program indicates that a road is.</p>
      <br><br></div><br><br>
      <div class="slidec">
                    <p>Importance of Traffic Level in Finding Road Safety</p>
          <span>Less  </span><input type="range" min="1" max="11" value="6" class = "slider" id="slider2"><span>    More</span><br><br>
          <p>Importance of Shoulder Size in Finding Road Safety</p>
          <span>Less  </span><input type="range" min="1" max="11" value="6" class = "slider" id="slider3"><span>    More</span><br><br>
          <p>Importance of Speed Limit in Finding Road Safety</p>
          <span>Less  </span><input type="range" min="1" max="11" value="6" class = "slider" id="slider4"><span>    More</span><br><br>
          <p>Overall Route Type</p>
          <span>Longer and Safer  </span><input type="range" min="0" max="100" value="50" class = "slider" id="slider"><span>    Shorter and Less Safe</span>

      </div>
      <br>
      Control Mode: <select id="slcmove">
          <option value="0">Select Start Point</option>
          <option value="1">Select Destination</option>
          <option value="2">Select Road</option>

      </select>
      <div id="roadcontrols"><br>
        Selected Road: <span id="sel">No Selection</span>
      <br><br>
      <button id="blacklist" onclick="blackliist()">Blacklist Selected Road</button><button id="whitelist" onclick="whiteliist()">Whitelist Selected Road</button>
      </div><br><br>
      <div id="map"></div>


    </body>

    <script>

      var LEFT = -76.549;
      var RIGHT = -75.619;
      var TOP = 43.305;
      var BOTTOM = 42.776;

      function findVT(coords1) {
        var vt1 = 0;
        var mn = 1000000000;

        for (var i = 0 ; i < graphx.length ; i++) {
          var lat = graphy[i];
          var lon = graphx[i];
          dist = dst(lat, lon, coords1[0], coords1[1]);
          if (dist < mn) {
            mn = dist;
            vt1 = i;
          }
        }



        return vt1;
      }

    var totalDistances = [];
    var totalLast = [];
    var graphx = [-1];
    var graphy = [-1];
    var edgeList = [];

    var dangers = [];
    var roadc = [];
    var roadn = [];
    var edgehash = [];

    var blacklist = [];
    var whitelist = [];
    var rblacklist = [];
    var rwhitelist = [];

    for (var i = 0 ; i < 1000000 ; i++) {
      blacklist.push(false);
      whitelist.push(false);
      rblacklist.push(false);
      rwhitelist.push(false);
    }

    function dangermap(car, shoulder, limit, fc1, fc2, fc3) {

      fc1 *= 3;
      fc3 *= 2;

      var cval = parseInt(((car * fc1) + (shoulder * fc2) + (limit * fc3)) / (fc1 + fc2 + fc3));

      if (shoulder >= 100) {
        cval = 75 + (car / 8) + (limit / 8);
      }

      return cval;
    }

    function readTextFile(file) {
      var rawFile = new XMLHttpRequest();
      rawFile.open("GET", file, false);
      rawFile.onreadystatechange = function() {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var allText = rawFile.responseText;
            allText = allText.split("\n");

            var t = 0;




            var len = parseInt(allText[t]);

            t++;

            for (var i = 0 ; i < len ; i++) {
              var line = allText[t].split(" ");
              var lat = parseFloat(line[1]);
              var lon = parseFloat(line[2]);

              graphx.push(lon);
              graphy.push(lat);
              t++;
            }

            var len2 = parseInt(allText[t]);
            t++;

            for (var i = 0 ; i < len2 ; i++) {
              var line = allText[t].split(" ");
              var e1 = parseInt(line[1]);
              var e2 = parseInt(line[2]);
              var d1 = parseInt(line[3]);
              var d2 = parseInt(line[4]);
              var d3 = parseInt(line[5]);

              edgehash[e1 * 10000000 + e2] = edgeList.length;
              edgehash[e2 * 10000000 + e1] = edgeList.length;



              edgeList.push([e1, e2, d1, d2, d3]);
              t++;
            }

            var len3 = parseInt(allText[t]);
            t++;

            for (var i = 0 ; i < len3 ; i ++) {
              var name = allText[t];
              t++;

              var len4 = allText[t];
              t++;

              var line = allText[t].split(" ");
              t++;

              for (var j = 0 ; j < len4 ; j++) {
                line[j] = parseInt(line[j]);
              }

              roadc.push(line);
              roadn.push(name);
            }


          }
        }
      }

      rawFile.send(null);
    }

    var shapes = [];
    var cc = 0;

    function dst(lat1, lon1, lat2, lon2) {
      //https://www.movable-type.co.uk/scripts/latlong.html

      const R = 6371e3; // metres
      const φ1 = lat1 * Math.PI/180; // φ, λ in radians
      const φ2 = lat2 * Math.PI/180;
      const Δφ = (lat2-lat1) * Math.PI/180;
      const Δλ = (lon2-lon1) * Math.PI/180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      const d = R * c; // in metres

      return (d / 1000) * 0.61;
    }

    //From https://codeburst.io/how-to-create-a-priority-queue-with-javascript-c56a970f29a8

    const leftChild = (index) => index * 2 + 1;
    const rightChild = (index) => index * 2 + 2;
    const parent = (index) => Math.floor((index - 1) / 2);

    function maxHeap() {
     this.heap = [];
    }


    maxHeap.prototype.swap = function (indexOne, indexTwo) {
     const tmp = this.heap[indexOne];
     this.heap[indexOne] = this.heap[indexTwo];
     this.heap[indexTwo] = tmp;
    }

    maxHeap.prototype.peek = function() {
      // the root is always the highest priority item
      return this.heap[0];
    }

    maxHeap.prototype.insert = function(element) {
      // push element to the end of the heap
      this.heap.push(element);

      // the index of the element we have just pushed
      let index = this.heap.length - 1;

      // if the element is greater than its parent:
      // swap element with its parent
      while (index !== 0 && this.heap[index] > this.heap[parent(index)]) {
        this.swap(index, parent(index));
        index = parent(index);
      }
    }

    maxHeap.prototype.extractMax = function() {
      // remove the first element from the heap
      const root = this.heap.shift();

      // put the last element to the front of the heap
      // and remove the last element from the heap as it now
      // sits at the front of the heap
      this.heap.unshift(this.heap[this.heap.length - 1]);
      this.heap.pop();

      // correctly re-position heap
      this.heapify(0);

      return root;
    }

    maxHeap.prototype.heapify = function(index) {
      let left = leftChild(index);
      let right = rightChild(index);
      let smallest = index;

      // if the left child is bigger than the node we are looking at
      if (left < this.heap.length && this.heap[smallest] < this.heap[left]) {
        smallest = left;
      }

      // if the right child is bigger than the node we are looking at
      if (right < this.heap.length && this.heap[smallest] < this.heap[right]) {
        smallest = right;
      }

      // if the value of smallest has changed, then some swapping needs to be done
      // and this method needs to be called again with the swapped element
      if (smallest != index) {
        this.swap(smallest, index);
        this.heapify(smallest);
      }
    }



    var mymap = L.map('map').setView([43.1, -76.2], 13);
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=sk.eyJ1IjoicGxvdXJkZTI3IiwiYSI6ImNram4yc3BuMjBsancydGx5OWI4eDgwZnIifQ.7MWGBl1SMiO6inaJ-6un0A', {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
      maxZoom: 18,
      id: 'mapbox/streets-v11',
      tileSize: 512,
      zoomOffset: -1,
      accessToken: 'sk.eyJ1IjoicGxvdXJkZTI3IiwiYSI6ImNram4yc3BuMjBsancydGx5OWI4eDgwZnIifQ.7MWGBl1SMiO6inaJ-6un0A'
  }).addTo(mymap);
  var circle = L.circle([42.98, -76.4], {
    color: 'red',
    fillColor: '#f03',
    fillOpacity: 0.5,
    radius: 50
  }).addTo(mymap);

    var adjList = [];

  function proclist(f1, f2, f3) {
    adjList = [];
    for (var i = 0 ; i < graphx.length + 1 ; i++) {
      adjList.push([]);
    }

    for (var i = 0 ; i < edgeList.length ; i++) {
      adjList[edgeList[i][0]].push([edgeList[i][1], dangermap(edgeList[i][2], edgeList[i][3], edgeList[i][4], f1, f2, f3), i]);
      adjList[edgeList[i][1]].push([edgeList[i][0], dangermap(edgeList[i][2], edgeList[i][3], edgeList[i][4], f1, f2, f3), i]);
    }
  }


  readTextFile("../dangerdata.txt");




    //console.log(edgeList);

    proclist(6, 6, 6);

    var end = parseInt(Math.random()*adjList.length);



    function runDijkstra(startNode, mspeed) {

      console.log("starting");

      var m = new maxHeap();

      var INFI = 1000000000;

      m.insert([INFI, startNode, -1, -1]);

      var distances = [];
      var lastvt = [];
      var lastspeed = [];
      for (var i = 0 ; i < adjList.length ; i++) {
        distances.push(-1);
        lastvt.push(-1);
        lastspeed.push(-1);
      }

      var ops = 0;

      while (m.heap.length > 0) {
        var inf = m.extractMax();
        var dist = INFI - inf[0];
        var vt = inf[1];
        var last = inf[2];
        var spd = inf[3];
        if (distances[vt] != -1) continue;
        distances[vt] = dist;
        lastvt[vt] = last;
        lastspeed[vt] = spd;
        //if (vt == endNode) break;
        for (var i = 0 ; i < adjList[vt].length ; i++) {

          if (blacklist[adjList[vt][i][2]] || (adjList[vt][i][1] > mspeed && !whitelist[adjList[vt][i][2]])) continue;

          var lon1 = graphx[vt];
          var lat1 = graphy[vt];
          var lon2 = graphx[adjList[vt][i][0]];
          var lat2 = graphy[adjList[vt][i][0]];
          var ds = dst(lat1, lon1, lat2, lon2) * (60 / 12);

          if (distances[adjList[vt][i][0]] != -1) continue;

          ops++;

          m.insert([INFI - (dist + ds), adjList[vt][i][0], vt, adjList[vt][i][1]]);
        }
      }

      //console.log(ops);

      return [distances, lastvt, lastspeed];

      //console.log("done");
    }

    var chained = [];
    for (var i = 0 ; i < 1000000 ; i++) {
      chained[i] = false;
    }

    function makeChain(lastvt, lastsp, endNode) {
      for (var i = 0 ; i < 1000000 ; i++) {
        chained[i] = false;
      }
      /*m.extractMax();

      m.insert([3, 0, 4]);
      m.insert([1, 3, 2]);
      m.insert([7, -3, -3]);*/



      var chain = [];
      var vertex = endNode;


      var ct = 0;

      while (ct < 200000) {
        if (vertex == -1) break;
        chained[vertex] = true;
        chain.push([vertex, lastsp[vertex]]);
        vertex = lastvt[vertex];
        ct++;
      }

      return chain;
    }








    function set(mspeed, vt) {

      var vt1 = 0;
      var vt2 = 0;
      var mn = 1000000000;

      /*for (var i = 0 ; i < adjList.length ; i++) {
        var lat = graphy[i];
        var lon = graphx[i];
        dist = dst(lat, lon, coords1[0], coords1[1]);
        if (dist < mn) {
          mn = dist;
          vt1 = i;
        }
      }*/

      vt1 = vt;

      mn = 1000000000;

      var stuff = runDijkstra(vt1, mspeed);
      var dist = stuff[0];

      return stuff;
    }

    function allDijkstra(vt, i) {


      var totalDistances = [];
      var totalLast = [];
      var totalSpeed = [];

      //for (var i = 0 ; i <= 100 ; i += 5) {
        var stuff = set(i, vt);
        var distances = stuff[0];
        var lastvt = stuff[1];
        var spd = stuff[2];
      //}

      return [distances, lastvt, spd];

    }

    var st = "";




    /*var polygon = L.polygon([[51.509, -0.08],[51.503, -0.06]], {
      color: 'rgba(255, 0, 0)',
    }).addTo(mymap);
      var circle = L.circle([lat, lon], {
        color: 'red',
        fillColor: '#f03',
        fillOpacity: 0.5,
        radius: 4
      }).addTo(mymap);
    }*/
    //System.out.println(xmlDoc);

    var chain = [];
    var shapes = [];

    var lastm = -1;
    var lastvt = -1;
    var lastvt2 = -1;
    var vt2 = 61859;
    var vt = 255858;
    var rv3 = -1;
    var mdg = -1;
    var ix = 0;
    var iy = 0;
    var lrv3 = rv3;
    var bl = false;
    var wl = false;
    var lwl = false;
    var lbl = false;
    var lf1 = -1;
    var lf2 = -1;
    var lf3 = -1;



    function animate() {




      if (rv3 != -1) {
        if (roadn[rv3].length < 3) {
          document.getElementById("sel").innerHTML = "Unnamed";
        }
        else {
          document.getElementById("sel").innerHTML = roadn[rv3];
        }
      }

      f1 = parseInt(document.getElementById("slider2").value);
      f2 = parseInt(document.getElementById("slider3").value);
      f3 = parseInt(document.getElementById("slider4").value);

      if (f1 != lf1 || f2 != lf2 || f3 != lf3) {
        console.log(f1 + " " + f2 + " " + f3);
        proclist(f1, f2, f3);
      }

      mdg = parseInt(document.getElementById("slider").value);

      if (f1 != lf1 || f2 != lf2 || f3 != lf3 || mdg != lastm || vt != lastvt || vt2 != lastvt2 || bl != lbl || wl != lwl) {

        var dk = allDijkstra(vt2, mdg);

        chain = makeChain(dk[1], dk[2], vt);

        console.log(vt);
      }

      lastm = mdg;
      lastvt = vt;
      lastvt2 = vt2;
      lrv3 = rv3;
      lbl = bl;
      lwl = wl;
      lf1 = f1;
      lf2 = f2;
      lf3 = f3;

      for (var i = 0 ; i < shapes.length ; i++) {
        shapes[i].remove();
      }

      /*for (var i = 0 ; i < chain.length ; i++) {

        if (chain[i][1] == -1) continue;

        var r = (chain[i][1]) * (255 / 100);
        var g = (100 -  chain[i][1]) * (255 / 100);
        var b = 0;

        var lat = graphy[chain[i][0]];
        var lon = graphx[chain[i][0]];
        var col = 'rgb(' + r + ', ' + g + ', ' + b + ')';


        if (i < chain.length - 1) {
          var points = [[lat, lon], [graphy[chain[i+1][0]], graphx[chain[i+1][0]]]];
          //var polyline = L.polygon(points, {color: 'black'}).addTo(map);
          var polygon = L.polyline(points, {
            color: col,
            weight: 5.6,
          }).addTo(mymap);
          shapes.push(polygon);
        }

      }*/

      var points5 = [[TOP, LEFT], [TOP, RIGHT]];
      var points6 = [[TOP, LEFT], [BOTTOM, LEFT]];
      var points7 = [[BOTTOM, LEFT], [BOTTOM, RIGHT]];
      var points8 = [[BOTTOM, RIGHT], [TOP, RIGHT]];

      var polygon = L.polyline(points5, {
        color: 'rgb(255, 0, 0)',
        weight: 10
      }).addTo(mymap);
      shapes.push(polygon);

      var polygon = L.polyline(points6, {
        color: 'rgb(255, 0, 0)',
        weight: 10
      }).addTo(mymap);
      shapes.push(polygon);

      var polygon = L.polyline(points7, {
        color: 'rgb(255, 0, 0)',
        weight: 10
      }).addTo(mymap);
      shapes.push(polygon);

      var polygon = L.polyline(points8, {
        color: 'rgb(255, 0, 0)',
        weight: 10
      }).addTo(mymap);
      shapes.push(polygon);

      for (var i = 0 ; i < edgeList.length ; i++) {
        var points4 = [[graphy[edgeList[i][0]], graphx[edgeList[i][0]]], [graphy[edgeList[i][1]], graphx[edgeList[i][1]]]];
        if (whitelist[i]) {
          var polygon = L.polyline(points4, {
            color: 'rgb(180, 180, 180)',
            weight: 4.6,
          }).addTo(mymap);
          shapes.push(polygon);
        }
        else if (blacklist[i]) {
          var polygon = L.polyline(points4, {
            color: 'rgb(0, 0, 0)',
            weight: 4.6,
          }).addTo(mymap);
          shapes.push(polygon);
        }
      }

      for (var i = 0 ; i < chain.length - 1 ; i++) {
        //console.log(edgeList[i][0] + " " + edgeList[i][1]);
        var r = (chain[i][1]) * (255 / 100);
        var g = (100 - chain[i][1]) * (255 / 100);
        var b = 0;


        var col = 'rgb(' + r + ', ' + g + ', ' + b + ')';

        var lat = graphy[chain[i][0]];
        var lon = graphx[chain[i][0]];
        var lat2 = graphy[chain[i+1][0]];
        var lon2 = graphx[chain[i+1][0]];

        var points = [[lat, lon], [lat + 0.01, lon + 0.01]];
        var points2 = [[lat, lon], [lat2, lon2]];

        var polygon = L.polyline(points2, {
          color: col,
          weight: 4.6,
        }).addTo(mymap);
        shapes.push(polygon);

        /*var polygon2 = L.polyline(points2, {
          color: col,
          weight: 0.6,
        }).addTo(mymap);*/
      }

      if (rv3 != -1) {
        for (var i = 0 ; i < roadc[rv3].length - 1 ; i++) {
          var lat1 = graphy[roadc[rv3][i]];
          var lon1 = graphx[roadc[rv3][i]];
          var lat2 = graphy[roadc[rv3][i + 1]];
          var lon2 = graphx[roadc[rv3][i + 1]];

          var points3 = [[lat1, lon1], [lat2, lon2]];

          if (!(lat1 && lon1 && lat2 && lon2)) continue;

          var col = 'rgb(255, 0, 0)';
          var polygon = L.polyline(points3, {
            color: col,
            weight: 2.6,
          }).addTo(mymap);
          shapes.push(polygon);

        }
      }



      var circle = L.circle([graphy[vt], graphx[vt]], {
        color: 'blue',
        fillColor: 'blue',
        fillOpacity: 0.2,
        radius: 270
      }).addTo(mymap);
      shapes.push(circle);

      var circle = L.circle([graphy[vt2], graphx[vt2]], {
        color: 'yellow',
        fillColor: 'yellow',
        fillOpacity: 0.2,
        radius: 270
      }).addTo(mymap);
      shapes.push(circle);

    }

    window.setInterval(animate, 1000);

    var type = 0;

    function updateslider() {
      type = parseInt(document.getElementById("slcmove").value, 10);

      if (type < 2) {
        document.getElementById("roadcontrols").style.display = "none";
      }
      else {
        document.getElementById("roadcontrols").style.display = "block";
      }


      if (rv3 != -1 && roadc[rv3].length >= 2) {
        var id = edgehash[roadc[rv3][0] * 10000000 + roadc[rv3][1]];
        bl = blacklist[id];
        wl = whitelist[id];
      }

      if (!bl) {
        document.getElementById("blacklist").innerHTML = "Blacklist Selected Road";
      }
      else {
        document.getElementById("blacklist").innerHTML = "Remove Blacklist";
      }

      if (!wl) {
        document.getElementById("whitelist").innerHTML = "Whitelist Selected Road";
      }
      else {
        document.getElementById("whitelist").innerHTML = "Remove Whitelist";
      }


    }

    window.setInterval(updateslider, 10);

    mymap.on('click', function(e) {
      if (type == 1) {
        vt = findVT([e.latlng.lat, e.latlng.lng]);
        console.log(vt);
      }
      else if (type == 0) {
        vt2 = findVT([e.latlng.lat, e.latlng.lng]);
        console.log(vt2);
      }
      else {
        var cat = e.latlng.lat
        var con = e.latlng.lng;
        rv3 = 0;
        var mn = 1000000000;
        var chchn = [];
        for (var i = 0 ; i < roadc.length ; i++) {
          /*var v1 = edgeList[i][0];
          var v2 = edgeList[i][1];
          var lat1 = graphy[v1];
          var lon1 = graphx[v1];
          var lat2 = graphy[v2];
          var lon2 = graphx[v2];
          var m1 = (lat2 - lat1) / (lon2 - lon1);
          var b1 = lat1 - m1 * lon1;
          var m2 = -1 / m1;
          var b2 = cat - m2 * con;
          ix = (b2 - b1) / (m1 - m2);
          iy = m1 * ix + b1;
          var ds = ((ix-con) * (ix-con) + (iy-cat) * (iy-cat))**0.5;
          if ( i== 0) {
            console.log(ds);
          }
          if (ds < mn) {
            mn = ds;
            //rv3 = i;
          }*/

          var chn = 0;



          for (var j = 0 ; j < roadc[i].length ; j++) {
            if (chained[roadc[i][j]]) {
              chn++;
            }
              var lat = graphy[roadc[i][j]];
              var lon = graphx[roadc[i][j]];

              var ds = dst(lat, lon, cat, con);

              if (ds < mn) {
                mn = ds;
                rv3 = i;
              }

          }
          if (chn >= 2) {
            chchn.push(i);
          }
        }

        mn = 1000000000;

        for (var k = 0 ; k < chchn.length ; k++) {
          var i = chchn[k];
          for (var j = 0 ; j < roadc[i].length ; j++) {

              var lat = graphy[roadc[i][j]];
              var lon = graphx[roadc[i][j]];

              var ds = dst(lat, lon, cat, con);

              if (ds < mn) {
                mn = ds;
                rv3 = i;
              }
            }
          }

      }


      //console.log(vt);

    });

    function blackliist() {
      if (document.getElementById("blacklist").innerHTML == "Blacklist Selected Road") {
        //document.getElementById("whitelist").innerHTML = "Whitelist Selected Road";
        //document.getElementById("blacklist").innerHTML = "Remove Blacklist";

        for (var i = 0 ; i < roadc[rv3].length - 1 ; i++) {
          var p1 = roadc[rv3][i];
          var p2 = roadc[rv3][i+1];
          var val = edgehash[p1 * 10000000 + p2];
          console.log(p1 + " " + p2);
          blacklist[val] = true;
          whitelist[val] = false;
        }
      }
      else {
        //document.getElementById("blacklist").innerHTML = "Blacklist Selected Road";

        for (var i = 0 ; i < roadc[rv3].length - 1 ; i++) {
          var p1 = roadc[rv3][i];
          var p2 = roadc[rv3][i+1];
          var val = edgehash[p1 * 10000000 + p2];

          blacklist[val] = false;
        }
      }
    }

    function whiteliist() {
      if (document.getElementById("whitelist").innerHTML == "Whitelist Selected Road") {
        //document.getElementById("blacklist").innerHTML = "Blacklist Selected Road";
        //document.getElementById("whiteist").innerHTML = "Remove Whitelist";

        for (var i = 0 ; i < roadc[rv3].length - 1 ; i++) {
          var p1 = roadc[rv3][i];
          var p2 = roadc[rv3][i+1];
          var val = edgehash[p1 * 10000000 + p2];

          whitelist[val] = true;
          blacklist[val] = false;
        }
      }
      else {
        //document.getElementById("whitelist").innerHTML = "Whitelist Selected Road";

        for (var i = 0 ; i < roadc[rv3].length - 1 ; i++) {
          var p1 = roadc[rv3][i];
          var p2 = roadc[rv3][i+1];
          var val = edgehash[p1 * 10000000 + p2];

          whitelist[val] = false;
        }
      }
    }



    </script>
</html>
